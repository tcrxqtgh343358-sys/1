<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>植物大战僵尸 - 3D矢量增强版</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background-color: #1a1a1a;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #game-wrapper {
            position: relative;
            box-shadow: 0 20px 50px rgba(0,0,0,0.9);
            border: 10px solid #4d2e1a;
            border-radius: 15px;
            overflow: hidden;
        }

        canvas {
            background-color: #4CAF50;
            display: block;
            cursor: crosshair;
        }

        #ui-bar {
            background: linear-gradient(180deg, #34495e 0%, #2c3e50 100%);
            width: 900px;
            height: 100px;
            display: flex;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            border-bottom: 4px solid #1a252f;
            border-radius: 15px 15px 0 0;
        }

        #sun-counter {
            background: rgba(0,0,0,0.3);
            border: 3px solid #f1c40f;
            border-radius: 10px;
            padding: 5px 20px;
            margin-right: 30px;
            display: flex;
            align-items: center;
            color: #f1c40f;
            font-weight: bold;
            font-size: 28px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .sun-icon {
            width: 30px;
            height: 30px;
            background: radial-gradient(circle at 30% 30%, #fff, #f1c40f 60%, #e67e22);
            border-radius: 50%;
            margin-right: 12px;
            box-shadow: 0 0 15px #f1c40f;
        }

        .card {
            width: 80px;
            height: 90px;
            background: #bdc3c7;
            border: 4px solid #7f8c8d;
            border-radius: 10px;
            margin-right: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 -5px 0 rgba(0,0,0,0.2);
        }

        .card:hover { transform: translateY(-5px); filter: brightness(1.1); }
        .card.active { border-color: #f1c40f; background: #ecf0f1; box-shadow: 0 0 20px #f1c40f; }
        .card.disabled { opacity: 0.6; cursor: not-allowed; filter: grayscale(1); }
        .card-cost { font-size: 16px; font-weight: bold; color: #2c3e50; margin-top: 5px; }

        #game-over-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        h1 { font-size: 80px; color: #e74c3c; margin: 0; text-shadow: 4px 4px 0 #000; }
        .restart-btn {
            background: #27ae60;
            border: none;
            padding: 15px 50px;
            font-size: 28px;
            color: white;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 30px;
            box-shadow: 0 8px 0 #1e8449;
        }
        .restart-btn:active { transform: translateY(4px); box-shadow: 0 4px 0 #1e8449; }
    </style>
</head>
<body>

<div id="ui-bar">
    <div id="sun-counter"><div class="sun-icon"></div> <span id="sun-display">150</span></div>
    
    <div class="card" id="card-shooter" onclick="selectPlant(0)">
        <div style="width:40px; height:40px; background:radial-gradient(circle at 30% 30%, #2ecc71, #27ae60); border-radius:50%; box-shadow: 2px 2px 5px rgba(0,0,0,0.3);"></div>
        <div class="card-cost">100</div>
    </div>

    <div class="card" id="card-sunflower" onclick="selectPlant(1)">
        <div style="width:40px; height:40px; background:radial-gradient(circle at 30% 30%, #f1c40f, #e67e22); border-radius:50%; box-shadow: 2px 2px 5px rgba(0,0,0,0.3);"></div>
        <div class="card-cost">50</div>
    </div>
</div>

<div id="game-wrapper">
    <canvas id="gameCanvas" width="900" height="500"></canvas>
    <div id="game-over-screen">
        <h1>GAME OVER</h1>
        <h2 style="color:#bdc3c7">僵尸吃掉了你的脑子！</h2>
        <h3 id="final-score" style="color:#f1c40f">得分: 0</h3>
        <button class="restart-btn" onclick="location.reload()">再次尝试</button>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const cellSize = 100;
const cols = 9;
const rows = 5;

let frame = 0;
let score = 0;
let gameOver = false;
let sunAmount = 150;
let selectedPlant = -1;

const defenders = [];
const enemies = [];
const projectiles = [];
const resources = [];
const mowers = [];

const mouse = { x: 0, y: 0, clicked: false };
const canvasRect = canvas.getBoundingClientRect();

// --- 辅助绘图函数 ---
function drawShadow(x, y, radius) {
    ctx.save();
    ctx.beginPath();
    ctx.ellipse(x, y + 40, radius, radius/2.5, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fill();
    ctx.restore();
}

// --- 实体类 ---

class LawnMower {
    constructor(y) {
        this.x = 10;
        this.y = y;
        this.width = 70;
        this.height = 60;
        this.active = false;
        this.speed = 12;
        this.used = false;
    }
    update() {
        if (this.active) {
            this.x += this.speed;
            enemies.forEach(enemy => {
                if (collision(this, enemy) && Math.abs(this.y - enemy.y) < 10) {
                    enemy.health = 0; // 秒杀核心逻辑
                }
            });
            if (this.x > canvas.width) this.used = true;
        }
    }
    draw() {
        if (this.used) return;
        ctx.save();
        ctx.translate(this.x, this.y + 20);
        
        // 阴影
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(30, 55, 40, 15, 0, 0, Math.PI*2); ctx.fill();

        // 红色车身（带渐变）
        let bodyGrad = ctx.createLinearGradient(0, 0, 0, 50);
        bodyGrad.addColorStop(0, '#e74c3c');
        bodyGrad.addColorStop(1, '#962d22');
        ctx.fillStyle = bodyGrad;
        ctx.fillRect(0, 10, 65, 35);
        
        // 引擎盖（立体感）
        ctx.fillStyle = '#c0392b';
        ctx.beginPath();
        ctx.moveTo(0, 10); ctx.lineTo(65, 10); ctx.lineTo(55, 0); ctx.lineTo(10, 0);
        ctx.fill();

        // 黑色轮子
        ctx.fillStyle = '#222';
        ctx.beginPath(); ctx.arc(15, 45, 12, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(50, 45, 12, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#666'; // 轮毂
        ctx.beginPath(); ctx.arc(15, 45, 5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(50, 45, 5, 0, Math.PI*2); ctx.fill();

        ctx.restore();
    }
}

class Resource {
    constructor(x, y) {
        this.x = x || Math.random() * (canvas.width - 100) + 50;
        this.y = y || -50;
        this.targetY = y ? y : Math.random() * (canvas.height - 150) + 50;
        this.speed = 1.5;
        this.angle = 0;
    }
    update() {
        if (this.y < this.targetY) this.y += this.speed;
        this.angle += 0.05;
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(Math.sin(this.angle) * 0.2);
        
        // 核心发光
        let grad = ctx.createRadialGradient(0, 0, 2, 0, 0, 30);
        grad.addColorStop(0, '#fff');
        grad.addColorStop(0.4, '#f1c40f');
        grad.addColorStop(1, 'rgba(241, 196, 15, 0)');
        
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(0, 0, 35, 0, Math.PI*2); ctx.fill();
        
        // 立体质感核心
        ctx.fillStyle = '#f39c12';
        ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(-5, -5, 3, 0, Math.PI*2); ctx.stroke();
        
        ctx.restore();
    }
}

class Projectile {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.width = 20; this.height = 20;
        this.speed = 7;
    }
    update() { this.x += this.speed; }
    draw() {
        drawShadow(this.x, this.y, 10);
        let grad = ctx.createRadialGradient(this.x-3, this.y-3, 2, this.x, this.y, 12);
        grad.addColorStop(0, '#a9dfbf');
        grad.addColorStop(1, '#1e8449');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(this.x, this.y, 12, 0, Math.PI*2); ctx.fill();
    }
}

class Defender {
    constructor(x, y, type) {
        this.x = x; this.y = y;
        this.width = cellSize; this.height = cellSize;
        this.type = type;
        this.health = 100;
        this.timer = 0;
    }
    draw() {
        const cx = this.x + cellSize/2;
        const cy = this.y + cellSize/2;
        drawShadow(cx, cy, 35);

        ctx.save();
        ctx.translate(cx, cy);

        if (this.type === 0) { // 豌豆射手 3D增强
            // 叶子底座
            ctx.fillStyle = '#1e8449';
            for(let i=0; i<4; i++) {
                ctx.rotate(Math.PI/2);
                ctx.beginPath(); ctx.ellipse(20, 0, 18, 8, 0, 0, Math.PI*2); ctx.fill();
            }
            // 茎部
            ctx.fillStyle = '#27ae60';
            ctx.fillRect(-5, 0, 10, 30);
            
            // 头部球体
            let headGrad = ctx.createRadialGradient(-8, -15, 5, 0, -10, 30);
            headGrad.addColorStop(0, '#58d68d');
            headGrad.addColorStop(1, '#1e8449');
            ctx.fillStyle = headGrad;
            ctx.beginPath(); ctx.arc(0, -10, 28, 0, Math.PI*2); ctx.fill();
            
            // 炮口
            ctx.fillStyle = '#145a32';
            ctx.beginPath(); ctx.ellipse(25, -10, 12, 15, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#1e8449';
            ctx.beginPath(); ctx.rect(5, -22, 20, 24); ctx.fill();
            
            // 眼睛
            ctx.fillStyle = 'black';
            ctx.beginPath(); ctx.arc(8, -18, 4, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.arc(9, -19, 1.5, 0, Math.PI*2); ctx.fill();

        } else { // 向日葵 3D增强
            // 茎
            ctx.fillStyle = '#27ae60';
            ctx.fillRect(-4, 10, 8, 30);
            
            // 花瓣
            ctx.fillStyle = '#f1c40f';
            for(let i=0; i<12; i++) {
                ctx.rotate(Math.PI/6);
                let petalGrad = ctx.createLinearGradient(10, 0, 35, 0);
                petalGrad.addColorStop(0, '#f39c12');
                petalGrad.addColorStop(1, '#f1c40f');
                ctx.fillStyle = petalGrad;
                ctx.beginPath(); ctx.ellipse(25, 0, 15, 7, 0, 0, Math.PI*2); ctx.fill();
            }
            
            // 花盘
            let faceGrad = ctx.createRadialGradient(0, 0, 5, 0, 0, 22);
            faceGrad.addColorStop(0, '#d35400');
            faceGrad.addColorStop(1, '#873600');
            ctx.fillStyle = faceGrad;
            ctx.beginPath(); ctx.arc(0, 0, 22, 0, Math.PI*2); ctx.fill();
            
            // 脸部细节
            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(0, 5, 10, 0.2, Math.PI-0.2); ctx.stroke();
            ctx.fillStyle = '#333';
            ctx.beginPath(); ctx.arc(-7, -4, 3, 0, Math.PI*2); ctx.arc(7, -4, 3, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }
    update() {
        this.timer++;
        if (this.type === 0) {
            if (this.timer % 100 === 0) {
                if (enemies.some(e => e.y === this.y && e.x > this.x)) {
                    projectiles.push(new Projectile(this.x + 80, this.y + 40));
                }
            }
        } else if (this.timer % 600 === 0) {
            resources.push(new Resource(this.x + 50, this.y + 50));
        }
    }
}

class Enemy {
    constructor(y) {
        this.x = canvas.width;
        this.y = y;
        this.width = cellSize;
        this.height = cellSize;
        this.speed = Math.random() * 0.3 + 0.4;
        this.movement = this.speed;
        this.health = 100;
        this.maxHealth = 100;
        this.frame = 0;
    }
    update() {
        this.x -= this.movement;
        this.frame += 0.08;
    }
    draw() {
        const cx = this.x + cellSize/2;
        const cy = this.y + cellSize/2;
        drawShadow(cx, cy, 30);

        ctx.save();
        ctx.translate(cx, cy);
        
        let bounce = Math.sin(this.frame) * 3;
        let tilt = Math.cos(this.frame) * 0.05;
        ctx.rotate(tilt);

        // 腿部
        ctx.fillStyle = '#2c3e50';
        ctx.fillRect(-10 + Math.sin(this.frame)*5, 20, 8, 25);
        ctx.fillRect(2 - Math.sin(this.frame)*5, 20, 8, 25);

        // 身体 (西装立体感)
        let bodyGrad = ctx.createLinearGradient(-15, 0, 15, 0);
        bodyGrad.addColorStop(0, '#34495e');
        bodyGrad.addColorStop(0.5, '#5d6d7e');
        bodyGrad.addColorStop(1, '#2c3e50');
        ctx.fillStyle = bodyGrad;
        ctx.fillRect(-18, -10 + bounce, 36, 35);

        // 手臂
        ctx.fillStyle = '#5B9075';
        ctx.beginPath();
        ctx.ellipse(-25, bounce, 15, 5, -0.4, 0, Math.PI*2);
        ctx.fill();

        // 头部 (方块立体感)
        ctx.fillStyle = '#4d7a63'; // 侧面暗部
        ctx.fillRect(-20, -48 + bounce, 40, 40);
        let headGrad = ctx.createLinearGradient(-20, -48, 20, -48);
        headGrad.addColorStop(0, '#5B9075');
        headGrad.addColorStop(1, '#82b399');
        ctx.fillStyle = headGrad;
        ctx.fillRect(-18, -46 + bounce, 34, 34);

        // 眼睛
        ctx.fillStyle = 'white';
        ctx.beginPath(); ctx.arc(-8, -35 + bounce, 6, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(8, -35 + bounce, 6, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'black';
        ctx.beginPath(); ctx.arc(-6, -35 + bounce, 2, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(10, -35 + bounce, 2, 0, Math.PI*2); ctx.fill();

        ctx.restore();

        // 血条
        if(this.health < this.maxHealth) {
            ctx.fillStyle = '#c0392b';
            ctx.fillRect(this.x + 20, this.y - 10, 60, 6);
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(this.x + 20, this.y - 10, 60 * (this.health/this.maxHealth), 6);
        }
    }
}

// --- 游戏核心循环与逻辑 ---

function collision(a, b) {
    return !(a.x > b.x + b.width || a.x + a.width < b.x || a.y > b.y + b.height || a.y + a.height < b.y);
}

function handleInteractions() {
    // 资源收集
    for (let i = 0; i < resources.length; i++) {
        let r = resources[i];
        if (mouse.clicked) {
            let dx = mouse.x - r.x;
            let dy = mouse.y - r.y;
            if (Math.sqrt(dx*dx + dy*dy) < 40) {
                sunAmount += 25;
                resources.splice(i, 1);
                updateUI();
                return;
            }
        }
    }

    // 种植
    if (mouse.clicked && selectedPlant !== -1) {
        let gx = Math.floor(mouse.x / cellSize) * cellSize;
        let gy = Math.floor(mouse.y / cellSize) * cellSize;
        
        if (gx >= 0 && gx < canvas.width && gy >= 0 && gy < canvas.height) {
            if (!defenders.some(d => d.x === gx && d.y === gy)) {
                let cost = selectedPlant === 0 ? 100 : 50;
                if (sunAmount >= cost) {
                    defenders.push(new Defender(gx, gy, selectedPlant));
                    sunAmount -= cost;
                    selectedPlant = -1;
                    resetCards();
                    updateUI();
                }
            }
        }
    }
}

function animate() {
    // 绘制草坪背景
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            ctx.fillStyle = (r + c) % 2 === 0 ? '#4CAF50' : '#45a049';
            ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);
        }
    }

    mowers.forEach(m => { m.update(); m.draw(); });
    
    // 植物逻辑
    for (let i = defenders.length - 1; i >= 0; i--) {
        defenders[i].update();
        defenders[i].draw();
        if (defenders[i].health <= 0) defenders.splice(i, 1);
    }

    // 僵尸逻辑
    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];
        e.update();
        e.draw();

        if (e.x < 0) {
            let mower = mowers.find(m => m.y === e.y && !m.used);
            if (mower) mower.active = true;
            else gameOver = true;
        }

        e.movement = e.speed;
        defenders.forEach(d => {
            if (collision(e, d)) {
                e.movement = 0;
                d.health -= 0.4;
            }
        });

        if (e.health <= 0) {
            enemies.splice(i, 1);
            score += 10;
        }
    }

    // 子弹逻辑
    for (let i = projectiles.length - 1; i >= 0; i--) {
        let p = projectiles[i];
        p.update();
        p.draw();
        enemies.forEach(e => {
            if (collision(p, e)) {
                e.health -= 25;
                projectiles.splice(i, 1);
            }
        });
        if (p.x > canvas.width) projectiles.splice(i, 1);
    }

    // 阳光掉落
    if (frame % 400 === 0) resources.push(new Resource());
    resources.forEach(r => { r.update(); r.draw(); });

    // 僵尸生成
    if (frame % 240 === 0 && frame > 100) {
        enemies.push(new Enemy(Math.floor(Math.random() * rows) * cellSize));
    }

    // 选中提示
    if (selectedPlant !== -1) {
        ctx.globalAlpha = 0.5;
        let gx = Math.floor(mouse.x / cellSize) * cellSize;
        let gy = Math.floor(mouse.y / cellSize) * cellSize;
        ctx.fillStyle = 'white';
        ctx.fillRect(gx, gy, cellSize, cellSize);
        ctx.globalAlpha = 1.0;
    }

    handleInteractions();
    mouse.clicked = false;
    frame++;

    if (!gameOver) requestAnimationFrame(animate);
    else {
        document.getElementById('game-over-screen').style.display = 'flex';
        document.getElementById('final-score').innerText = "最终得分: " + score;
    }
}

// --- 初始化与UI控制 ---

canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
});
canvas.addEventListener('mousedown', () => mouse.clicked = true);

function selectPlant(type) {
    if (type === 0 && sunAmount < 100) return;
    if (type === 1 && sunAmount < 50) return;
    selectedPlant = type;
    resetCards();
    document.getElementById(type === 0 ? 'card-shooter' : 'card-sunflower').classList.add('active');
}

function resetCards() {
    document.querySelectorAll('.card').forEach(c => c.classList.remove('active'));
}

function updateUI() {
    document.getElementById('sun-display').innerText = sunAmount;
    document.getElementById('card-shooter').classList.toggle('disabled', sunAmount < 100);
    document.getElementById('card-sunflower').classList.toggle('disabled', sunAmount < 50);
}

for (let i = 0; i < rows; i++) mowers.push(new LawnMower(i * cellSize));
updateUI();
animate();

</script>
</body>
</html>